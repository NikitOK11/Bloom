// This is your Prisma schema file
// Learn more at: https://pris.ly/d/prisma-schema

// ARCHITECTURE DECISION:
// We use SQLite for simplicity in MVP. It's file-based, 
// requires no external database server, and is perfect for development.
// Can be easily swapped to PostgreSQL for production.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

// ==========================================
// USER MODEL - AUTHENTICATION ONLY
// ==========================================
// DOMAIN RULE: User represents authentication identity only.
// Personal information is stored in the Profile model.
// This separation allows:
// - Clear domain boundaries (auth vs profile data)
// - Users can exist without profiles (pre-onboarding state)
// - Profile can be required for certain actions (e.g., join requests)
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String   @default("") // Hashed password (placeholder for MVP, default empty for migration)
  name      String   // Display name for identification
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  createdTeams Team[]        @relation("TeamCreator")
  teamMembers  TeamMember[]
  joinRequests JoinRequest[] // User's requests to join teams
  profile      Profile?      // 1-to-1 relation to Profile (optional until created)
}

// ==========================================
// PROFILE MODEL - USER'S EXTENDED INFO
// ==========================================
// DOMAIN RULE: Profile is REQUIRED to:
// - Send join requests to teams
// - Be visible to team leaders reviewing requests
// 
// PRIVACY RULE: Profiles are NOT publicly browsable.
// They can only be viewed by:
// 1. The profile owner (for editing)
// 2. Team leaders reviewing join requests from this user
//
// FLOW: User registers → User creates profile → User can join teams
model Profile {
  id                 String   @id @default(cuid())
  role               String   @default("school_student") // school_student, college_student, graduate, other
  gradeOrYear        String?  // e.g., "11th grade", "2nd year", "PhD"
  interests          String   // Comma-separated: "algorithms,ml,data_science"
  skills             String   @default("") // Comma-separated: "python,sql,math"
  olympiadExperience String?  // Free text about past olympiad participation
  about              String?  // General "about me" section
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // 1-to-1 relation to User
  userId String @unique
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// Olympiad Model
// Represents an academic olympiad competition.
// Teams can be associated with a specific olympiad.
// Updated: Now supports Russian olympiads with structured data
model Olympiad {
  id          String    @id @default(cuid())
  slug        String    @unique // URL-friendly identifier: "icpc", "nto-ai"
  name        String    // Original name (never translated)
  shortName   String    @unique // Short code for display: "ICPC", "НТО"
  description String?   // Russian description
  year        Int       // Competition year
  level       String    @default("смешанная") // "школьная", "студенческая", "смешанная"
  subject     String    // Main discipline for backwards compatibility
  disciplines String?   // Comma-separated: "Алгоритмы,ML,Data Science"
  teamSize    String?   // Russian string: "3–5 человек"
  format      String?   // "онлайн", "оффлайн", "смешанный"
  organizer   String?   // Organizer name
  website     String?   // Official website URL
  logoEmoji   String?   // Emoji for visual identity
  startDate   DateTime? // Competition start date
  endDate     DateTime? // Competition end date
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  teams Team[]
}

// Team Model
// DOMAIN RULE: A team MUST belong to exactly one olympiad.
// Teams cannot exist independently - they are always created
// within the context of a specific olympiad competition.
// This ensures data integrity and clear team-olympiad association.
model Team {
  id             String   @id @default(cuid())
  name           String
  description    String?
  requiredSkills String   // Comma-separated skills needed
  maxMembers     Int      @default(4)
  isOpen         Boolean  @default(true) // Whether team is accepting members
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // TEAM REQUIREMENTS:
  // These fields help users understand what the team is looking for
  // and enable smart filtering on the team list page.
  requiredInterests String?  // Comma-separated: "algorithms,machine_learning,data_science"
  requiredLevel     String   @default("any") // "beginner", "intermediate", "advanced", "any"
  requirementsNote  String?  // Short free-text note from team leader about what they're looking for

  // Relations
  creatorId    String
  creator      User          @relation("TeamCreator", fields: [creatorId], references: [id])
  members      TeamMember[]
  joinRequests JoinRequest[] // Incoming join requests for this team
  
  // Required relation to Olympiad - teams must belong to an olympiad
  olympiadId  String
  olympiad    Olympiad     @relation(fields: [olympiadId], references: [id])
}

// TeamMember Model (Join Table)
// Links users to teams with additional metadata.
// Allows tracking when someone joined and their role.
model TeamMember {
  id       String   @id @default(cuid())
  role     String   @default("member") // "creator" or "member"
  joinedAt DateTime @default(now())

  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Ensure a user can only be in a team once
  @@unique([userId, teamId])
}

// JoinRequest Model
// DOMAIN RULE: Users cannot be added to teams directly.
// They must submit a join request that the team leader approves.
// This ensures proper control over team membership.
model JoinRequest {
  id        String   @id @default(cuid())
  // Status: "PENDING", "APPROVED", "REJECTED"
  // Using String instead of enum for SQLite compatibility
  status    String   @default("PENDING")
  message   String?  // Optional message from the requester
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  teamId String
  team   Team   @relation(fields: [teamId], references: [id], onDelete: Cascade)

  // Ensure a user can only have one active request per team
  // Note: This doesn't prevent multiple requests with different statuses,
  // but business logic enforces only one PENDING request at a time
  @@unique([userId, teamId, status])
  @@index([teamId, status]) // For efficient querying of pending requests
}
